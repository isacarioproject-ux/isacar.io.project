[
  {
    "projectId": "9da8e04b-142e-436d-8a5c-1c8e31c6a233",
    "testId": "caa7eb2c-d4b7-4657-8306-b5b401eda105",
    "userId": "54387408-d0c1-7024-7356-d6734e097c80",
    "title": "TC001-Add New Recurring Bill Inline",
    "description": "Verify that a user can add a new recurring bill using the inline form without any page reload, and that the new bill appends to the bottom of the list with correct data.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input email and password, then click Sign In button to authenticate.\n        frame = context.pages[-1]\n        # Input email address\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('kleovekleh@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('24948180@Kk')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Verify login success or retry login process.\n        frame = context.pages[-1]\n        # Click Sign In button again to retry login\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Minha finança' to navigate to the finance page where Recurring Bills block is located.\n        frame = context.pages[-1]\n        # Click on 'Minha finança' to go to finance page\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/div/div[2]/div/ul/li[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down or search the page to locate the Recurring Bills block and the 'Add New' inline form button.\n        await page.mouse.wheel(0, 400)\n        \n\n        # -> Search for or scroll to locate the Recurring Bills block or an 'Add New' button to add a recurring bill.\n        await page.mouse.wheel(0, 400)\n        \n\n        # -> Try to find a way to reveal or navigate to the Recurring Bills block, possibly by clicking on a menu or tab related to recurring bills or finances.\n        frame = context.pages[-1]\n        # Click on 'Pessoal' button to check if it reveals Recurring Bills block or related options\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Recurring Bill Added Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan execution failed to verify adding a new recurring bill inline without page reload, appending the new bill at the bottom with correct data, and backend synchronization.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The Recurring Bills block or 'Add New' inline form is not visible or accessible on the finance page under the 'Pessoal' workspace. Unable to proceed with adding a new recurring bill as per the task instructions. Task stopped.\nBrowser Console Logs:\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)\n[ERROR] Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s%s \n\nCheck the render method of `Primitive.button.SlotClone`. \n    at DropdownMenu (http://localhost:3005/src/components/ui/dropdown-menu.tsx:26:28)\n    at http://localhost:3005/node_modules/.vite/deps/chunk-KZUPDE7K.js?v=3b0866c3:50:13\n    at http://localhost:3005/node_modules/.vite/deps/chunk-KZUPDE7K.js?v=3b0866c3:27:13\n    at http://localhost:3005/node_modules/.vite/deps/chunk-KZUPDE7K.js?v=3b0866c3:140:13\n    at http://localhost:3005/node_modules/.vite/deps/chunk-KZUPDE7K.js?v=3b0866c3:50:13\n    at http://localhost:3005/node_modules/.vite/deps/chunk-KZUPDE7K.js?v=3b0866c3:27:13\n    at http://localhost:3005/node_modules/.vite/deps/chunk-KZUPDE7K.js?v=3b0866c3:140:13\n    at http://localhost:3005/node_modules/.vite/deps/chunk-GPDDVIEQ.js?v=3b0866c3:1963:13\n    at http://localhost:3005/node_modules/.vite/deps/@radix-ui_react-tooltip.js?v=3b0866c3:298:13\n    at TooltipTrigger (http://localhost:3005/src/components/ui/tooltip.tsx:54:30)\n    at Provider (http://localhost:3005/node_modules/.vite/deps/chunk-N2ODAK4M.js?v=3b0866c3:38:15)\n    at Provider (http://localhost:3005/node_modules/.vite/deps/chunk-N2ODAK4M.js?v=3b0866c3:38:15)\n    at Popper (http://localhost:3005/node_modules/.vite/deps/chunk-GPDDVIEQ.js?v=3b0866c3:1955:11)\n    at Tooltip (http://localhost:3005/node_modules/.vite/deps/@radix-ui_react-tooltip.js?v=3b0866c3:206:5)\n    at Provider (http://localhost:3005/node_modules/.vite/deps/chunk-N2ODAK4M.js?v=3b0866c3:38:15)\n    at TooltipProvider (http://localhost:3005/node_modules/.vite/deps/@radix-ui_react-tooltip.js?v=3b0866c3:162:5)\n    at TooltipProvider (http://localhost:3005/src/components/ui/tooltip.tsx:25:28)\n    at Tooltip (http://localhost:3005/src/components/ui/tooltip.tsx:37:23)\n    at div\n    at Provider (http://localhost:3005/node_modules/.vite/deps/chunk-N2ODAK4M.js?v=3b0866c3:38:15)\n    at TooltipProvider (http://localhost:3005/node_modules/.vite/deps/@radix-ui_react-tooltip.js?v=3b0866c3:162:5)\n    at TooltipProvider (http://localhost:3005/src/components/ui/tooltip.tsx:25:28)\n    at div\n    at div\n    at CardHeader (http://localhost:3005/src/components/ui/card.tsx:35:23)\n    at div\n    at Card (http://localhost:3005/src/components/ui/card.tsx:23:17)\n    at div\n    at div\n    at ResizableCard (http://localhost:3005/src/components/ui/resizable-card.tsx:27:37)\n    at TasksCard (http://localhost:3005/src/components/tasks/tasks-card.tsx?t=1763027142284:46:29)\n    at div\n    at DraggableCardWrapper (http://localhost:3005/src/components/draggable-card-wrapper.tsx:26:40)\n    at div\n    at SortableContext (http://localhost:3005/node_modules/.vite/deps/@dnd-kit_sortable.js?v=3b0866c3:261:5)\n    at DndContext2 (http://localhost:3005/node_modules/.vite/deps/chunk-AKUQWHWU.js?v=3b0866c3:2521:5)\n    at div\n    at div\n    at main\n    at div\n    at div\n    at Provider (http://localhost:3005/node_modules/.vite/deps/chunk-N2ODAK4M.js?v=3b0866c3:38:15)\n    at TooltipProvider (http://localhost:3005/node_modules/.vite/deps/@radix-ui_react-tooltip.js?v=3b0866c3:162:5)\n    at TooltipProvider (http://localhost:3005/src/components/ui/tooltip.tsx:25:28)\n    at http://localhost:3005/src/components/ui/sidebar.tsx:52:72\n    at DashboardLayout (http://localhost:3005/src/components/dashboard-layout.tsx?t=1763027142284:34:35)\n    at DashboardPage (http://localhost:3005/src/pages/dashboard.tsx?t=1763028368464:37:19)\n    at RenderedRoute (http://localhost:3005/node_modules/.vite/deps/react-router-dom.js?v=3b0866c3:5624:26)\n    at Routes (http://localhost:3005/node_modules/.vite/deps/react-router-dom.js?v=3b0866c3:6518:3)\n    at Suspense\n    at WorkspaceProvider (http://localhost:3005/src/contexts/workspace-context.tsx:26:37)\n    at SubscriptionProvider (http://localhost:3005/src/contexts/subscription-context.tsx:27:40)\n    at AuthProvider (http://localhost:3005/src/contexts/auth-context.tsx:25:32)\n    at Router (http://localhost:3005/node_modules/.vite/deps/react-router-dom.js?v=3b0866c3:6461:13)\n    at BrowserRouter (http://localhost:3005/node_modules/.vite/deps/react-router-dom.js?v=3b0866c3:9563:3)\n    at V (http://localhost:3005/node_modules/.vite/deps/next-themes.js?v=3b0866c3:44:25)\n    at J (http://localhost:3005/node_modules/.vite/deps/next-themes.js?v=3b0866c3:42:18)\n    at ThemeProvider (http://localhost:3005/src/components/theme-provider.tsx:22:33)\n    at App (http://localhost:3005/src/App.tsx?t=1763028368464:65:5) (at http://localhost:3005/node_modules/.vite/deps/chunk-3IHV7RO6.js?v=3b0866c3:520:37)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54387408-d0c1-7024-7356-d6734e097c80/1763028689388234//tmp/test_task/result.webm",
    "created": "2025-11-13T10:07:36.387Z",
    "modified": "2025-11-13T10:11:29.552Z"
  },
  {
    "projectId": "9da8e04b-142e-436d-8a5c-1c8e31c6a233",
    "testId": "8b7d2e40-05e8-4794-a69a-6b96353fd6c7",
    "userId": "54387408-d0c1-7024-7356-d6734e097c80",
    "title": "TC002-Inline Edit Existing Recurring Bill Fields",
    "description": "Verify users can edit existing recurring bill fields (name, amount, category, due day) inline, save changes on blur or Enter key, and cancel edits on Escape key without page reloads.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Recurring Bill Edit Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan to verify inline editing of recurring bill fields failed. Expected to see confirmation text 'Recurring Bill Edit Successful' which does not exist, indicating the inline edit and save functionality did not work as intended.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54387408-d0c1-7024-7356-d6734e097c80/1763028562754943//tmp/test_task/result.webm",
    "created": "2025-11-13T10:07:36.395Z",
    "modified": "2025-11-13T10:09:22.898Z"
  },
  {
    "projectId": "9da8e04b-142e-436d-8a5c-1c8e31c6a233",
    "testId": "889ec029-f58f-4b16-9fe9-ff0e2e26404f",
    "userId": "54387408-d0c1-7024-7356-d6734e097c80",
    "title": "TC003-Delete Recurring Bill Inline",
    "description": "Verify users can delete a recurring bill inline with immediate UI update, no full page reload, and data synchronization with backend.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Recurring bill deletion successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The recurring bill item was not removed immediately in the UI, or the backend synchronization did not occur as expected. This indicates the delete functionality is broken or the UI did not update optimistically as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54387408-d0c1-7024-7356-d6734e097c80/1763028575579455//tmp/test_task/result.webm",
    "created": "2025-11-13T10:07:36.401Z",
    "modified": "2025-11-13T10:09:35.717Z"
  },
  {
    "projectId": "9da8e04b-142e-436d-8a5c-1c8e31c6a233",
    "testId": "193665d7-3708-4c65-b2f3-a697ea878cff",
    "userId": "54387408-d0c1-7024-7356-d6734e097c80",
    "title": "TC004-Calendar Picker Mobile Responsiveness and Touch Support",
    "description": "Verify the calendar picker for due day selection is fully functional, visible, and touch-optimized on mobile devices for selecting dates.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Due Day Selection Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The calendar picker for due day selection is not fully functional, visible, or touch-optimized on mobile devices as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54387408-d0c1-7024-7356-d6734e097c80/1763028563215818//tmp/test_task/result.webm",
    "created": "2025-11-13T10:07:36.408Z",
    "modified": "2025-11-13T10:09:23.333Z"
  },
  {
    "projectId": "9da8e04b-142e-436d-8a5c-1c8e31c6a233",
    "testId": "3ae0dc82-6178-40f0-9fb9-e0a313687d6a",
    "userId": "54387408-d0c1-7024-7356-d6734e097c80",
    "title": "TC005-Offline Support Data Caching and Synchronization",
    "description": "Verify that when offline, the application caches recurring bills data, allows edits and additions offline, and synchronizes all changes upon reconnection.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Offline Recurring Bills Sync Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test failed: Offline mode caching, editing, addition, and synchronization of recurring bills did not complete successfully as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54387408-d0c1-7024-7356-d6734e097c80/1763028567732874//tmp/test_task/result.webm",
    "created": "2025-11-13T10:07:36.414Z",
    "modified": "2025-11-13T10:09:27.860Z"
  },
  {
    "projectId": "9da8e04b-142e-436d-8a5c-1c8e31c6a233",
    "testId": "9dc9aafb-a107-49a5-ad69-371046591bb8",
    "userId": "54387408-d0c1-7024-7356-d6734e097c80",
    "title": "TC006-Optimistic UI and State Management Verification",
    "description": "Verify that inline edits, additions, and deletions reflect immediately in local state with optimistic UI updates, and no unnecessary API calls or full data reloads are triggered.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Full Data Reload Triggered').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The inline edits, additions, and deletions did not reflect immediately in local state with optimistic UI updates, or unnecessary full data reloads were triggered, violating the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54387408-d0c1-7024-7356-d6734e097c80/1763028565418445//tmp/test_task/result.webm",
    "created": "2025-11-13T10:07:36.420Z",
    "modified": "2025-11-13T10:09:25.552Z"
  },
  {
    "projectId": "9da8e04b-142e-436d-8a5c-1c8e31c6a233",
    "testId": "d65efe7b-3922-4ff6-9408-eb8069c945e5",
    "userId": "54387408-d0c1-7024-7356-d6734e097c80",
    "title": "TC007-Keyboard Shortcuts and Escape Key Cancellation",
    "description": "Verify that pressing Enter saves inline edits, pressing Escape cancels edits reverting to original values, and keyboard shortcuts function correctly in the Recurring Bills block.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Inline Edit Saved Successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The inline edit save functionality did not work as expected in the Recurring Bills block. Pressing Enter should save edits, but this was not observed.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54387408-d0c1-7024-7356-d6734e097c80/1763028577225722//tmp/test_task/result.webm",
    "created": "2025-11-13T10:07:36.426Z",
    "modified": "2025-11-13T10:09:37.350Z"
  },
  {
    "projectId": "9da8e04b-142e-436d-8a5c-1c8e31c6a233",
    "testId": "32a09a46-2fd3-4437-aedd-b7f689293d6a",
    "userId": "54387408-d0c1-7024-7356-d6734e097c80",
    "title": "TC008-Responsive UI Verification Across Breakpoints",
    "description": "Verify the Recurring Bills block and its components correctly render and function on small (sm), medium (md), and large (lg) screen sizes, including mobile devices.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Recurring Bills Block Not Found').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The Recurring Bills block did not render or function correctly across small, medium, and large screen sizes as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54387408-d0c1-7024-7356-d6734e097c80/1763028574531123//tmp/test_task/result.webm",
    "created": "2025-11-13T10:07:36.432Z",
    "modified": "2025-11-13T10:09:34.664Z"
  },
  {
    "projectId": "9da8e04b-142e-436d-8a5c-1c8e31c6a233",
    "testId": "7686a70b-81b7-4d2c-8da4-d41a22be44ce",
    "userId": "54387408-d0c1-7024-7356-d6734e097c80",
    "title": "TC009-Internationalization Rendering and Input Support",
    "description": "Verify that the Recurring Bills block supports multiple languages (pt-BR, en, es) properly, including translations in UI, inline forms, calendar pickers, and notifications.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Idioma não suportado').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The Recurring Bills block does not properly support multiple languages (pt-BR, en, es) as required by the test plan. UI translations, calendar pickers, and notifications are not correctly displayed.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54387408-d0c1-7024-7356-d6734e097c80/1763028565678764//tmp/test_task/result.webm",
    "created": "2025-11-13T10:07:36.438Z",
    "modified": "2025-11-13T10:09:25.804Z"
  },
  {
    "projectId": "9da8e04b-142e-436d-8a5c-1c8e31c6a233",
    "testId": "602eabcc-bda1-4d6f-9513-9fb0b6431b77",
    "userId": "54387408-d0c1-7024-7356-d6734e097c80",
    "title": "TC010-Financial Data Visualization Real-Time Update",
    "description": "Verify that financial charts and category summaries related to recurring bills update in real-time as bill data changes (add, edit, delete) and reflect backend data modifications.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Recurring Bill Successfully Added').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The financial charts and category summaries related to recurring bills did not update in real-time as expected after adding, editing, or deleting bill data.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54387408-d0c1-7024-7356-d6734e097c80/1763028558824429//tmp/test_task/result.webm",
    "created": "2025-11-13T10:07:36.448Z",
    "modified": "2025-11-13T10:09:18.942Z"
  },
  {
    "projectId": "9da8e04b-142e-436d-8a5c-1c8e31c6a233",
    "testId": "31f6e306-dd2e-4f4b-a0de-a949a4542885",
    "userId": "54387408-d0c1-7024-7356-d6734e097c80",
    "title": "TC011-Drag and Drop Sortable Blocks Interaction",
    "description": "Verify users can customize the finance dashboard by dragging and dropping sortable blocks including Recurring Bills, ensuring proper rearrangement and state persistence.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Dashboard Customization Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The finance dashboard customization test did not pass. The Recurring Bills block could not be reordered or its position did not persist after refresh as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54387408-d0c1-7024-7356-d6734e097c80/1763028565698338//tmp/test_task/result.webm",
    "created": "2025-11-13T10:07:36.462Z",
    "modified": "2025-11-13T10:09:25.895Z"
  },
  {
    "projectId": "9da8e04b-142e-436d-8a5c-1c8e31c6a233",
    "testId": "723ce412-e2d6-4561-bffb-93feb078eb8c",
    "userId": "54387408-d0c1-7024-7356-d6734e097c80",
    "title": "TC012-Event Propagation and Page Reload Prevention",
    "description": "Verify that interactions within the Recurring Bills block, such as inline edits, calendar picker usage, and add/delete operations do not trigger unwanted event propagation causing page reloads.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3005/auth\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Unexpected Page Reload Detected').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Interactions within the Recurring Bills block triggered an unwanted page reload, violating the test plan requirements.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)\n[WARNING] Permissão de geolocalização negada pelo usuário (at http://localhost:3005/src/lib/tasks/reminder-location-service.ts:33:28)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54387408-d0c1-7024-7356-d6734e097c80/1763028562866637//tmp/test_task/result.webm",
    "created": "2025-11-13T10:07:36.531Z",
    "modified": "2025-11-13T10:09:22.986Z"
  }
]
